<html>

<head>
    <script src="box2d_min.js"></script>
    <script src="embox2d-helpers.js"></script>
</head>

<body>
    <canvas>

    </canvas>
    <script>

        function createPolygonShape(vertices) {
            var shape = new Box2D.b2PolygonShape();
            var buffer = Box2D.allocate(vertices.length * 8, 'float', Box2D.ALLOC_STACK);
            var offset = 0;
            for (var i = 0; i < vertices.length; i++) {
                Box2D.setValue(buffer + (offset), vertices[i].get_x(), 'float'); // x
                Box2D.setValue(buffer + (offset + 4), vertices[i].get_y(), 'float'); // y
                offset += 8;
            }
            var ptr_wrapped = Box2D.wrapPointer(buffer, Box2D.b2Vec2);
            shape.Set(ptr_wrapped, vertices.length);
            return shape;
        }







        let c = document.querySelector("canvas");
        c.width = 500;
        c.height = 500;
        let ctx = c.getContext('2d');

        //make a world
        var world = new Box2D.b2World(new Box2D.b2Vec2(0.0, -10.0));

        //Make the universe background anchor
        //var groundBody = world.CreateBody(new Box2D.b2BodyDef());

        // Make the floor
        var bodyDef = new Box2D.b2BodyDef();
        //bodyDef.set_type(Box2D.b2_dynamicBody);
        var body = world.CreateBody(bodyDef);
        var fixtureDef = new b2FixtureDef();
        var edgeShape = new b2EdgeShape();
        edgeShape.Set(new b2Vec2(-20, -12), new b2Vec2(2000, -12));
        fixtureDef.set_shape(edgeShape);
        fixtureDef.get_filter().set_categoryBits(0xff);
        body.CreateFixture(fixtureDef);

        //Make a box
        var bodyDef = new Box2D.b2BodyDef();
        bodyDef.set_type(Box2D.b2_dynamicBody);

        var verts = [];
        verts.push(new Box2D.b2Vec2(0, -2.5));
        verts.push(new Box2D.b2Vec2(10, -2.5));
        verts.push(new Box2D.b2Vec2(10, 2.5));
        verts.push(new Box2D.b2Vec2(0, 2.5));
        var polygonShape = createPolygonShape(verts);
        var fixtureDef = new b2FixtureDef();
        fixtureDef.set_density(2.5);
        fixtureDef.set_friction(0.6);
        fixtureDef.get_filter().set_categoryBits(0x01);
        fixtureDef.get_filter().set_maskBits(0x10);
        fixtureDef.set_shape(polygonShape);
        let basePosition = new Box2D.b2Vec2(0, 0);
        let dynamicBodies = [];
        for (let i = 0; i < 5; i++) {
            dynamicBodies.push(world.CreateBody(bodyDef));
            dynamicBodies[i].CreateFixture(fixtureDef);
            dynamicBodies[i].SetTransform(basePosition, -Math.PI / 2);
        }
        //join all parts together
        var jointDef2 = new b2RevoluteJointDef();
        jointDef2.set_bodyA(dynamicBodies[0]);
        jointDef2.set_bodyB(dynamicBodies[1]);
        jointDef2.set_localAnchorA(new b2Vec2(12, 0));
        jointDef2.set_localAnchorB(new b2Vec2(-2, 0));
        jointDef2.set_collideConnected(false);
        jointDef2.set_enableLimit(true);
        jointDef2.set_lowerAngle(-Math.PI / 2);
        jointDef2.set_upperAngle(0);
        var revoluteJoint2 = Box2D.castObject(world.CreateJoint(jointDef2), b2WheelJoint);

        var jointDef2 = new b2RevoluteJointDef();
        jointDef2.set_bodyA(dynamicBodies[2]);
        jointDef2.set_bodyB(dynamicBodies[3]);
        jointDef2.set_localAnchorA(new b2Vec2(12, 0));
        jointDef2.set_localAnchorB(new b2Vec2(-2, 0));
        jointDef2.set_collideConnected(false);
        jointDef2.set_enableLimit(true);
        jointDef2.set_lowerAngle(-Math.PI / 2);
        jointDef2.set_upperAngle(0);
        var revoluteJoint2 = Box2D.castObject(world.CreateJoint(jointDef2), b2WheelJoint);

        var jointDef2 = new b2RevoluteJointDef();
        jointDef2.set_bodyA(dynamicBodies[0]);
        jointDef2.set_bodyB(dynamicBodies[2]);
        jointDef2.set_localAnchorA(new b2Vec2(-2, 0));
        jointDef2.set_localAnchorB(new b2Vec2(-2, 0));
        jointDef2.set_collideConnected(false);
        jointDef2.set_enableLimit(true);
        jointDef2.set_lowerAngle(-Math.PI / 6);
        jointDef2.set_upperAngle(Math.PI / 6);
        var revoluteJoint2 = Box2D.castObject(world.CreateJoint(jointDef2), b2WheelJoint);

        var jointDef2 = new b2RevoluteJointDef();
        jointDef2.set_bodyA(dynamicBodies[4]);
        jointDef2.set_bodyB(dynamicBodies[0]);
        jointDef2.set_localAnchorA(new b2Vec2(12, 0));
        jointDef2.set_localAnchorB(new b2Vec2(-2, 0));
        jointDef2.set_collideConnected(false);
        jointDef2.set_enableLimit(true);
        jointDef2.set_lowerAngle(0);
        jointDef2.set_upperAngle(Math.PI / 2);
        var revoluteJoint2 = Box2D.castObject(world.CreateJoint(jointDef2), b2WheelJoint);

        let tt = 0;
        // sim
        function update(){
            ctx.fillStyle = "white";
            ctx.fillRect(0, 0, 500, 500);
            world.Step(0.1, 8, 3);
            for (b of dynamicBodies) {
                let cx = b.GetPosition().get_x() + 20;
                let cy = b.GetPosition().get_y() + 20;
                let angle = b.GetAngle();
                ctx.beginPath();
                let xx = [10, 10, 0, 0];
                let yy = [0, 5, 5, 0];
                ctx.moveTo(cx + xx[3] * Math.cos(angle) - yy[3] * Math.sin(angle), 500 - (cy + xx[3] * Math.sin(angle) + yy[3] * Math.cos(angle)));
                for (let i = 0; i < 4; i++) {
                    ctx.lineTo(cx + xx[i] * Math.cos(angle) - yy[i] * Math.sin(angle), 500 - (cy + xx[i] * Math.sin(angle) + yy[i] * Math.cos(angle)));
                }
                ctx.stroke();
                ctx.closePath();
            }
            dynamicBodies[0].ApplyTorque(-20000 * Math.sin(tt / 10));
            dynamicBodies[2].ApplyTorque(-20000 * Math.sin((tt + 5) / 10));
            dynamicBodies[1].ApplyTorque(-20000 * Math.sin(tt / 10));
            dynamicBodies[3].ApplyTorque(-20000 * Math.sin((tt + 5) / 10));
            //dynamicBodies[0].ApplyTorque(-100000 * Math.sin(tt / 1000));
            tt++;
            if (tt == 1000) {
                for (let i = 0; i < 5; i++) {
                    dynamicBodies[i].SetTransform(basePosition, -Math.PI / 2);
                }
                tt=0;
            }
            requestAnimationFrame(update);
        }

        update();



    </script>

</body>

</html>